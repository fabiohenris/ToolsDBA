# Fala galera, criei esse shell para ajudar quem tiver o mesmo problema que eu
# Que √© levantar os hist√≥ricos das inst√¢ncias SQL, saber a chave utilizada (principal) e outras informa√ß√µes.
# Como esta √© a primeira vers√£o, aos poucos irei incrementar mais informa√ß√µes para serem apresentadas.

# Desenvolvido : Fabio Henrique da Silva
# LinkedIn   : https://www.linkedin.com/in/fabio-henriques/

# Libera temporariamente a execu√ß√£o de scripts para inst√¢ncia
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass

# Verifica e instala m√≥dulo SqlServer
if (-not (Get-Module -ListAvailable -Name SqlServer)) {
    Write-Host "üì¶ M√≥dulo 'SqlServer' n√£o encontrado. Instalando..."
    try {
        Install-Module -Name SqlServer -Force -Scope CurrentUser -ErrorAction Stop -AllowClobber
        Write-Host "‚úÖ M√≥dulo 'SqlServer' instalado com sucesso."
    } catch {
        Write-Host "‚ùå Falha ao instalar o m√≥dulo 'SqlServer': $($_.Exception.Message)"
        return
    }
}

try {
    Import-Module SqlServer -ErrorAction Stop
    Write-Host "üì• M√≥dulo 'SqlServer' carregado com sucesso.`n"
} catch {
    Write-Host "‚ùå Erro ao importar o m√≥dulo 'SqlServer': $($_.Exception.Message)"
    return
}

# Fun√ß√£o para coletar informa√ß√µes de hardware do servidor
function Get-HardwareInfo {
    Write-Host "üñ•Ô∏è Informa√ß√µes de Hardware do Servidor`n"

    # Sistema Operacional
    $os = Get-CimInstance Win32_OperatingSystem
    $installDateRaw = $os.InstallDate
    try {
        $installDate = [System.Management.ManagementDateTimeConverter]::ToDateTime($installDateRaw)
    } catch {
        $installDate = $installDateRaw
    }
    Write-Host "üõ°Ô∏è SO           : $($os.Caption) (Vers√£o $($os.Version)) - Instalado em: $installDate"

    # CPU
    $cpus = Get-CimInstance Win32_Processor
    foreach ($cpu in $cpus) {
        Write-Host "üß† CPU          : $($cpu.Name) - Cores: $($cpu.NumberOfCores) - Threads: $($cpu.NumberOfLogicalProcessors) - Clock: $($cpu.MaxClockSpeed) MHz"
    }

    # Mem√≥ria F√≠sica
    $cs = Get-CimInstance Win32_ComputerSystem
    $totalMemGB = [Math]::Round($cs.TotalPhysicalMemory / 1GB, 2)
    Write-Host "üíæ Mem√≥ria Total: $totalMemGB GB"

    # Discos (DriveType 3 = Discos Fixos)
    $drives = Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3"
    foreach ($d in $drives) {
        $sizeGB      = [Math]::Round($d.Size / 1GB, 2)
        $freeGB      = [Math]::Round($d.FreeSpace / 1GB, 2)
        $percentFree = [Math]::Round(($d.FreeSpace / $d.Size) * 100, 2)
        $volName     = if ($d.VolumeName) { $d.VolumeName } else { 'Sem r√≥tulo' }
        Write-Host "üóÑÔ∏è Disco $($d.DeviceID) - Nome: $volName - $freeGB GB livre de $sizeGB GB ($percentFree% livre)"
    }

    # Placas de Rede
    $nics = Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }
    foreach ($nic in $nics) {
        Write-Host "üåê NIC          : $($nic.Description) - IPs: $($nic.IPAddress -join ', ')"
    }

    Write-Host ""  # Linha em branco final
}

# Fun√ß√£o para decodificar a chave de produto do SQL Server
function Get-SqlServerProductKey {
    param ([string]$InstanceName)

    $localMachine = [Microsoft.Win32.RegistryHive]::LocalMachine
    $view         = [Microsoft.Win32.RegistryView]::Default
    $reg          = [Microsoft.Win32.RegistryKey]::OpenBaseKey($localMachine, $view)
    $keyPath      = "SOFTWARE\Microsoft\Microsoft SQL Server\$InstanceName\Setup"

    try {
        $encodedData = $reg.OpenSubKey($keyPath).GetValue("DigitalProductID")
        $reg.Close()

        if (-not $encodedData) {
            Write-Host "‚ùå DigitalProductID n√£o encontrada para a inst√¢ncia: $InstanceName"
            return
        }

        $binArray   = $encodedData[0..66]
        $charsArray = "B","C","D","F","G","H","J","K","M","P","Q","R","T","V","W","X","Y","2","3","4","6","7","8","9"
        $productKey = ""

        for ($i = 24; $i -ge 0; $i--) {
            $k = 0
            for ($j = 14; $j -ge 0; $j--) {
                $k = ($k * 256) -bxor $binArray[$j]
                $binArray[$j] = [math]::truncate($k / 24)
                $k %= 24
            }
            $productKey = $charsArray[$k] + $productKey
            if (($i % 5 -eq 0) -and ($i -ne 0)) { $productKey = "-" + $productKey }
        }

        Write-Host "üîë Chave do Produto: $productKey"
    } catch {
        Write-Host "‚ö†Ô∏è Erro ao decodificar a chave para ${InstanceName}: $($_.Exception.Message)"
    }
}

# Fun√ß√£o principal para coletar informa√ß√µes de todas as inst√¢ncias SQL Server
function Get-AllSQLServerInfo {
    Write-Host "üîç Iniciando varredura de inst√¢ncias SQL Server instaladas...`n"

    $instances = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server').InstalledInstances
    if (-not $instances) {
        Write-Host "‚ùå Nenhuma inst√¢ncia SQL Server encontrada neste servidor."
        return
    }

    foreach ($instance in $instances) {
        $instanceName = if ($instance -eq 'MSSQLSERVER') { 'localhost' } else { "localhost\$instance" }
        Write-Host "`n===============================
üìå Inst√¢ncia: $instanceName
==============================="

        # Coleta propriedades do SQL Server
        $query = @"
SELECT
    SERVERPROPERTY('MachineName') AS MachineName,
    SERVERPROPERTY('ServerName') AS ServerName,
    SERVERPROPERTY('InstanceName') AS InstanceName,
    SERVERPROPERTY('Edition') AS Edition,
    SERVERPROPERTY('ProductVersion') AS ProductVersion,
    SERVERPROPERTY('ProductLevel') AS ProductLevel,
    SERVERPROPERTY('IsIntegratedSecurityOnly') AS IsIntegratedSecurityOnly
"@

        try {
            $sqlInfo = Invoke-Sqlcmd -ServerInstance $instanceName -Query $query -TrustServerCertificate -ErrorAction Stop
            $sqlInfo | Format-List
        } catch {
            Write-Host ("‚ùå Erro ao conectar √† inst√¢ncia {0}: {1}" -f $instanceName, $_.Exception.Message)
            continue
        }

        # Informa√ß√µes do registro de instala√ß√£o
        $setupKey = "HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\$instance\Setup"
        if (Test-Path $setupKey) {
            $regInfo = Get-ItemProperty -Path $setupKey
            Write-Host "üìÅ Caminho de Instala√ß√£o: $($regInfo.SQLPath)"
            Write-Host "üìÖ Data de Instala√ß√£o : $($regInfo.InstallDate)"
        }

        # Servi√ßo do Windows
        $svcName = if ($instance -eq 'MSSQLSERVER') { 'MSSQLSERVER' } else { "MSSQL`$$instance" }
        try {
            $svc = Get-Service -Name $svcName -ErrorAction Stop
            Write-Host "‚öôÔ∏è Servi√ßo       : $($svc.DisplayName)"
            Write-Host "üîÑ Status        : $($svc.Status)"
            Write-Host "üïì Inicializa√ß√£o : $($svc.StartType)"
        } catch {
            Write-Host "‚ö†Ô∏è Servi√ßo $svcName n√£o encontrado ou inacess√≠vel."
        }

        # Tipo de edi√ß√£o
        switch ($sqlInfo.Edition) {
            'Express Edition'   { Write-Host 'üÜì Edi√ß√£o gratuita ‚Äî n√£o requer ativa√ß√£o.' }
            'Developer Edition' { Write-Host 'üß™ Edi√ß√£o para desenvolvimento ‚Äî sem expira√ß√£o.' }
            default             { Write-Host '‚úÖ Edi√ß√£o comercial ‚Äî verifique o contrato de licen√ßa.' }
        }

        # Tamanho do diret√≥rio SQL
        if ($regInfo.SQLPath -and (Test-Path $regInfo.SQLPath)) {
            try {
                $sizeBytes = (Get-ChildItem -Path $regInfo.SQLPath -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
                $sizeGB = [Math]::Round($sizeBytes / 1GB, 2)
                Write-Host "üíΩ Tamanho do Diret√≥rio SQL: $sizeGB GB"
            } catch {
                Write-Host '‚ö†Ô∏è Falha ao calcular o tamanho do diret√≥rio.'
            }
        }

        # Decodifica chave de produto
        try {
            $mapKey = 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL'
            $sqlKeyMap = Get-ItemProperty -Path $mapKey
            $keyName = $sqlKeyMap.$instance
            if ($keyName) { Get-SqlServerProductKey -InstanceName $keyName } else { Write-Host "‚ö†Ô∏è Mapeamento de inst√¢ncia n√£o encontrado para $instance." }
        } catch {
            Write-Host "‚ö†Ô∏è Erro ao recuperar mapeamento de inst√¢ncia: $($_.Exception.Message)"
        }
    }

    Write-Host "`n‚úÖ Varredura conclu√≠da.`n"
}

# Executa a varredura completa
Get-HardwareInfo
Get-AllSQLServerInfo
